C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 21:06:13 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ______
OBJECT MODULE PLACED IN .\Objects\配电柜.obj
COMPILER INVOKED BY: D:\SoftWare\Keil\C51\BIN\C51.EXE 配电柜.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\配电柜.lst) OBJECT(.\Objects\配电柜.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <ProtocolParsing.H>
   3          #include <MODBUS.H>
   4          #include <UART.H>
   5          #include <intrins.h>
   6          TYPE_PACK dat_buf;                      //解析信息的结构体
   7          TYPE_MODBUS xdata modbus_struct_buf;
   8          
   9          char xdata UART1_recv_buf[300]; //接收缓存
  10          char xdata modbus_buf[255];
  11          
  12          
  13          uint UATR1_buf_count;                           //接收缓存计数
  14          bit UATR1_clear_flag = 1;                       //接收缓存计数清除标志
  15          bit UATR1_rece_flag;                            //接收标志
  16          bit UATR2_rece_flag;                            //接收标志
  17          unsigned char xdata modbus_count = 0;
  18          
  19          void Delay1000ms();
  20          void DataDarsing(void);
  21          
  22          void main()
  23          {
  24   1              Uart1Init();                    //9600bps@24.000MHz
  25   1              Uart2Init();            //9600bps@24.000MHz
  26   1              EA = 1;
  27   1              while(1)
  28   1              {
  29   2                      DataDarsing();
  30   2                      
  31   2                      
  32   2                      if(!P73)
  33   2                      {       
  34   3                              Send2String(MakeModbus(0x01,0x03,0x0017,50),8);
  35   3                              P66 = 0;
  36   3                              while(!UATR2_rece_flag);
  37   3                              P66 = 1;
  38   3                              modbus_struct_buf = ModbusParsing(modbus_buf);
  39   3                              Send1Data(0X00);
  40   3                              Send1Data(0X01);
  41   3                              Send1Data(0X17);
  42   3      //                      Send1String(aaa,110);
  43   3      
  44   3                              Send1String(AgreementPackaging(ADDRESS,NUMBER,0xff03, modbus_struct_buf.len + 10, modbus_struct_buf.dat
             -),modbus_struct_buf.len + 10);
  45   3                              
  46   3                              P67 = 0;
  47   3                              while(!P73);
  48   3                              P67 = 1;
  49   3                              UATR2_rece_flag = 0;
  50   3                              modbus_count = 0;
  51   3                      }
  52   2              }
  53   1      }
C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 21:06:13 PAGE 2   

  54          
  55          
  56          void Uart1() interrupt 4                                                //串口1接收中断
  57          {
  58   1              static uint UART1_rece_len;                                     //声明静态变量，用于存储应接收到的字节数
  59   1              if (RI)
  60   1              {
  61   2                      RI = 0;                                                         //清除S2RI位
  62   2                      if(SBUF == 0X7E && UATR1_clear_flag)    //判断到帧头，数据处理完后UATR1_clear_flag要置1
  63   2                      { 
  64   3                              UATR1_buf_count = 0;                            //清除计数标志
  65   3                              UATR1_clear_flag = 0;                           //清除计数标志清空标志
  66   3                      }
  67   2                      
  68   2                      UART1_recv_buf[UATR1_buf_count] = SBUF; //将接收到的字符存储
  69   2                      
  70   2                      if(UATR1_buf_count == 7)                                //接收到了包长度数据
  71   2                      {
  72   3                              UART1_rece_len = UART1_recv_buf[6] << 8 | UART1_recv_buf[7];    //合成包长度数据
  73   3                      }
  74   2                      if(UATR1_buf_count == UART1_rece_len - 1)//本包数据接收完毕
  75   2                      {
  76   3                              UATR1_rece_flag = 1;                            //对UART1_recv_buf处理完成后要将其清零
  77   3                      }
  78   2                      UATR1_buf_count++;                      
  79   2              }
  80   1      }
  81          
  82          void Uart2() interrupt 8
  83          {
  84   1              static uchar UART2_recv_len;                            //声明静态变量，用于存储应接收到的字节数
  85   1              
  86   1              if (S2CON & 0x01)
  87   1              {
  88   2                      S2CON &= ~0x01;                                         //清除S2RI位
  89   2                      
  90   2                      modbus_buf[modbus_count] = S2BUF; 
  91   2                      
  92   2                      if(modbus_count == 2)
  93   2                      {
  94   3                              UART2_recv_len = modbus_buf[2];
  95   3                      }
  96   2                      
  97   2                      if(modbus_count == UART2_recv_len + 4)
  98   2                      {
  99   3                              UATR2_rece_flag = 1;
 100   3                      }
 101   2                      
 102   2                      modbus_count++;
 103   2              }
 104   1      }
 105          
 106          
 107          void Delay1000ms()              //@24.000MHz
 108          {
 109   1              unsigned char i, j, k;
 110   1      
 111   1              _nop_();
 112   1              _nop_();
 113   1              i = 92;
 114   1              j = 50;
 115   1              k = 238;
C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 21:06:13 PAGE 3   

 116   1              do
 117   1              {
 118   2                      do
 119   2                      {
 120   3                              while (--k);
 121   3                      } while (--j);
 122   2              } while (--i);
 123   1      }
 124          
 125          void DataDarsing(void)
 126          {
 127   1              if(UATR1_rece_flag)
 128   1              {
 129   2                      dat_buf = UnpackAgreement(UART1_recv_buf);      //解析数据包，将解析结果存到dat_buf中
 130   2                      
 131   2                      if(dat_buf.error == -1)
 132   2                      {
 133   3                              P60 = !P60;
 134   3                              if(dat_buf.com == 0xff20)       //判断是否为查询指令
 135   3                              {
 136   4                                      P61 = !P61;
 137   4                                      Send2String(MakeModbus(0x01,0x03,0x0017,25),8);
 138   4                                      P66 = 0;
 139   4                                      while(!UATR2_rece_flag);
 140   4                                      P66 = 1;
 141   4                                      modbus_struct_buf = ModbusParsing(modbus_buf);
 142   4                                      Send1Data(0X00);
 143   4                                      Send1Data(0X01);
 144   4                                      Send1Data(0X17);
 145   4                                      Send1String(AgreementPackaging(ADDRESS,NUMBER,0xff03, modbus_struct_buf.len + 10 , 
 146   4                                                                                                      modbus_struct_buf.dat),modbus_struct_buf.len + 10);
 147   4                                      while(P07 == 0);
 148   4                                      UATR2_rece_flag = 0;
 149   4                                      modbus_count = 0;
 150   4                                      P63 = !P63;
 151   4                              }
 152   3                      }
 153   2                      /*
 154   2                      *以下代码包含数据接收异常时的处理
 155   2                      */
 156   2                      else                                                    //如果接收到的数据包有误
 157   2                      {
 158   3                              P67 = !P67;;
 159   3                              if(dat_buf.error == 2)          //本机地址错误，进行相应的处理，可忽略，下同
 160   3                              {
 161   4                                      P62 = 0;
 162   4                                      Delay1000ms();
 163   4                                      P62 = 1;
 164   4                              }
 165   3                              if(dat_buf.error == 3)  //本机编号错误
 166   3                              {
 167   4                                      P63 = 0;
 168   4                                      Delay1000ms();
 169   4                                      P63 = 1;
 170   4                              }
 171   3                              if(dat_buf.error == 4)  //数据长度异常
 172   3                              {
 173   4                                      P64 = 0;
 174   4                                      Delay1000ms();
 175   4                                      P64 = 1;
 176   4                              }
 177   3                              if(dat_buf.error == 6)  //crc检验未通过
C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 21:06:13 PAGE 4   

 178   3                              {
 179   4                                      P65 = 0;
 180   4                                      Delay1000ms();
 181   4                                      P65 = 1;
 182   4                              }
 183   3                      }
 184   2                      UATR1_clear_flag = 1;
 185   2                      UATR1_rece_flag = 0;
 186   2              }
 187   1      }
 188          
 189          
 190          
 191          
 192          
 193          
 194          
 195          
 196          
 197          
 198          
 199          
 200          
 201          
 202          
 203          
 204          
 205          
 206          
 207          
 208          
 209          
 210          
 211          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    633    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    561    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

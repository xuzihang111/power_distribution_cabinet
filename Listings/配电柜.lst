C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 16:03:58 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ______
OBJECT MODULE PLACED IN .\Objects\配电柜.obj
COMPILER INVOKED BY: D:\SoftWare\Keil\C51\BIN\C51.EXE 配电柜.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\配电柜.lst) OBJECT(.\Objects\配电柜.obj)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <ProtocolParsing.H>
   3          #include <MODBUS.H>
   4          #include <UART.H>
   5          #include <intrins.h>
   6          TYPE_PACK dat_buf;                      //解析信息的结构体
   7          TYPE_MODBUS xdata modbus_struct_buf;
   8          
   9          char xdata UART1_recv_buf[300]; //接收缓存
  10          char xdata modbus_buf[255];
  11          char *p;
  12          
  13          uint UATR1_buf_count;                           //接收缓存计数
  14          bit UATR1_clear_flag = 1;                       //接收缓存计数清除标志
  15          bit UATR1_rece_flag;                            //接收标志
  16          bit UATR2_rece_flag;                            //接收标志
  17          unsigned char xdata modbus_count = 0;
  18          
  19          char code aaa[] = {"Qwertyuiop[asdfghjkl;zxcvbnm,.qwertyuiopasdfghjkQwertyuiop[asdfghjkl;zxcvbnm,.qwertyui
             -opasdfghjk45346534543636"};
  20          
  21          void Delay1000ms()              //@24.000MHz
  22          {
  23   1              unsigned char i, j, k;
  24   1      
  25   1              _nop_();
  26   1              _nop_();
  27   1              i = 92;
  28   1              j = 50;
  29   1              k = 238;
  30   1              do
  31   1              {
  32   2                      do
  33   2                      {
  34   3                              while (--k);
  35   3                      } while (--j);
  36   2              } while (--i);
  37   1      }
  38          
  39          
  40          void main()
  41          {
  42   1              Uart1Init();                    //9600bps@24.000MHz
  43   1              Uart2Init();            //9600bps@24.000MHz
  44   1              EA = 1;
  45   1              while(1)
  46   1              {
  47   2                      if(UATR1_rece_flag)
  48   2                      {
  49   3                              dat_buf = UnpackAgreement(UART1_recv_buf);      //解析数据包，将解析结果存到dat_buf中
  50   3                              
  51   3                              if(dat_buf.error == -1)
  52   3                              {
  53   4                                                              P60 = !P60;
C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 16:03:58 PAGE 2   

  54   4                                      if(dat_buf.com == 0xff20)       //判断是否为查询指令
  55   4                                      {
  56   5      //                                      Send2String(dat_buf.dat,dat_buf.len - 10);
  57   5                                              P61 = !P61;
  58   5                                              Send2String(MakeModbus(0x01,0x03,0x0017,25),8);
  59   5                                              P66 = 0;
  60   5                                              while(!UATR2_rece_flag);
  61   5                                              P66 = 1;
  62   5                                              modbus_struct_buf = ModbusParsing(modbus_buf);
  63   5                              Send1Data(0X00);
  64   5                              Send1Data(0X01);
  65   5                              Send1Data(0X17);
  66   5                                              Send1String(AgreementPackaging(ADDRESS,NUMBER,0xff03, modbus_struct_buf.len + 10 , 
  67   5                                                                                                              modbus_struct_buf.dat),modbus_struct_buf.len + 10);
  68   5                                              while(P07 == 1);
  69   5                                              UATR2_rece_flag = 0;
  70   5                                              modbus_count = 0;
  71   5                                          P63 = !P63;
  72   5                                      }
  73   4                                                                      
  74   4                              }
  75   3                              else                                                    //如果接收到的数据包有误
  76   3                              {
  77   4                                      P67 = !P67;;
  78   4                                      if(dat_buf.error == 2)          //本机地址错误，进行相应的处理，可忽略，下同
  79   4                                      {
  80   5                                              P62 = 0;
  81   5                                              Delay1000ms();
  82   5                                              P62 = 1;
  83   5                                      }
  84   4                                      if(dat_buf.error == 3)  //本机编号错误
  85   4                                      {
  86   5                                              P63 = 0;
  87   5                                              Delay1000ms();
  88   5                                              P63 = 1;
  89   5                                      }
  90   4                                      if(dat_buf.error == 4)  //数据长度异常
  91   4                                      {
  92   5                                              P64 = 0;
  93   5                                              Delay1000ms();
  94   5                                              P64 = 1;
  95   5                                      }
  96   4                                      if(dat_buf.error == 6)  //crc检验未通过
  97   4                                      {
  98   5                                              P65 = 0;
  99   5                                              Delay1000ms();
 100   5                                              P65 = 1;
 101   5                                      }
 102   4                              }
 103   3                              UATR1_clear_flag = 1;
 104   3                              UATR1_rece_flag = 0;
 105   3                      }
 106   2                      
 107   2                      
 108   2                      
 109   2                      if(!P73)
 110   2                      {       
 111   3                              Send2String(MakeModbus(0x01,0x03,0x0017,50),8);
 112   3                              P66 = 0;
 113   3                              while(!UATR2_rece_flag);
 114   3                              P66 = 1;
 115   3                              modbus_struct_buf = ModbusParsing(modbus_buf);
C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 16:03:58 PAGE 3   

 116   3                              Send1Data(0X00);
 117   3                              Send1Data(0X01);
 118   3                              Send1Data(0X17);
 119   3                              Send1String(aaa,110);
 120   3      
 121   3      //                      Send1String(AgreementPackaging(ADDRESS,NUMBER,0xff03, modbus_struct_buf.len + 10, modbus_struct_buf.d
             -at),modbus_struct_buf.len + 10);
 122   3                              
 123   3                              P67 = 0;
 124   3                              while(!P73);
 125   3                              P67 = 1;
 126   3                              UATR2_rece_flag = 0;
 127   3                              modbus_count = 0;
 128   3                      }
 129   2              }
 130   1      }
 131          
 132          
 133          void Uart1() interrupt 4                                                //串口1接收中断
 134          {
 135   1              static uint UART1_rece_len;                                     //声明静态变量，用于存储应接收到的字节数
 136   1              if (RI)
 137   1              {
 138   2                      RI = 0;                                                         //清除S2RI位
 139   2                      if(SBUF == 0X7E && UATR1_clear_flag)    //判断到帧头，数据处理完后UATR1_clear_flag要置1
 140   2                      { 
 141   3                              UATR1_buf_count = 0;                            //清除计数标志
 142   3                              UATR1_clear_flag = 0;                           //清除计数标志清空标志
 143   3                      }
 144   2                      
 145   2                      UART1_recv_buf[UATR1_buf_count] = SBUF; //将接收到的字符存储
 146   2                      
 147   2                      if(UATR1_buf_count == 7)                                //接收到了包长度数据
 148   2                      {
 149   3                              UART1_rece_len = UART1_recv_buf[6] << 8 | UART1_recv_buf[7];    //合成包长度数据
 150   3                      }
 151   2                      if(UATR1_buf_count == UART1_rece_len - 1)//本包数据接收完毕
 152   2                      {
 153   3                              UATR1_rece_flag = 1;                            //对UART1_recv_buf处理完成后要将其清零
 154   3                      }
 155   2                      UATR1_buf_count++;                      
 156   2              }
 157   1      }
 158          
 159          void Uart2() interrupt 8
 160          {
 161   1              static uchar UART2_recv_len;                            //声明静态变量，用于存储应接收到的字节数
 162   1              
 163   1              if (S2CON & 0x01)
 164   1              {
 165   2                      S2CON &= ~0x01;                                         //清除S2RI位
 166   2                      
 167   2                      modbus_buf[modbus_count] = S2BUF; 
 168   2                      
 169   2                      if(modbus_count == 2)
 170   2                      {
 171   3                              UART2_recv_len = modbus_buf[2];
 172   3                      }
 173   2                      
 174   2                      if(modbus_count == UART2_recv_len + 4)
 175   2                      {
 176   3                              UATR2_rece_flag = 1;
C51 COMPILER V9.56.0.0   ______                                                            03/18/2018 16:03:58 PAGE 4   

 177   3                      }
 178   2                      
 179   2                      modbus_count++;
 180   2              }
 181   1      }
 182          
 183          
 184          
 185          
 186          
 187          
 188          
 189          
 190          
 191          
 192          
 193          
 194          
 195          
 196          
 197          
 198          
 199          
 200          
 201          
 202          
 203          
 204          
 205          
 206          
 207          
 208          
 209          
 210          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    591    ----
   CONSTANT SIZE    =    111    ----
   XDATA SIZE       =    561    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
